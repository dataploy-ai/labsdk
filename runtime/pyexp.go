/*
cgo stubs for package pyexp.
File is generated by gopy. Do not edit.
gopy build -output=runtime -vm=python3 github.com/natun-ai/natun/pkg/pyexp
*/

package main

/*

#cgo CFLAGS: -I/usr/local/opt/python@3.9/Frameworks/Python.framework/Versions/3.9/include/python3.9 -Wno-error -Wno-implicit-function-declaration -Wno-int-conversion
#cgo LDFLAGS: -L/usr/local/opt/python@3.9/Frameworks/Python.framework/Versions/3.9/lib -lpython3.9 -ldl   -framework CoreFoundation

// #define Py_LIMITED_API // need full API for PyRun*
#include <Python.h>
typedef uint8_t bool;
// static inline is trick for avoiding need for extra .c file
// the following are used for build value -- switch on reflect.Kind
// or the types equivalent
static inline PyObject* gopy_build_bool(uint8_t val) {
	return Py_BuildValue("b", val);
}
static inline PyObject* gopy_build_int64(int64_t val) {
	return Py_BuildValue("k", val);
}
static inline PyObject* gopy_build_uint64(uint64_t val) {
	return Py_BuildValue("K", val);
}
static inline PyObject* gopy_build_float64(double val) {
	return Py_BuildValue("d", val);
}
static inline PyObject* gopy_build_string(const char* val) {
	return Py_BuildValue("s", val);
}
static inline void gopy_decref(PyObject* obj) { // macro
	Py_XDECREF(obj);
}
static inline void gopy_incref(PyObject* obj) { // macro
	Py_XINCREF(obj);
}
static inline int gopy_method_check(PyObject* obj) { // macro
	return PyMethod_Check(obj);
}
static inline void gopy_err_handle() {
	if(PyErr_Occurred() != NULL) {
		PyErr_Print();
	}
}

*/
import "C"
import (
	"reflect"
	"unsafe"

	"github.com/go-python/gopy/gopyh" // handler

	"context"
	"time"

	"github.com/go-logr/logr"
	"github.com/natun-ai/natun/api"
	"github.com/natun-ai/natun/pkg/pyexp"
)

// main doesn't do anything in lib / pkg mode, but is essential for exe mode
func main() {

}

// initialization functions -- can be called from python after library is loaded
// GoPyInitRunFile runs a separate python file -- call in GoPyInit if it
// steals the main thread e.g., for GUI event loop, as in GoGi startup.

//export GoPyInit
func GoPyInit() {

}

// type for the handle -- int64 for speed (can switch to string)
type GoHandle int64
type CGoHandle C.longlong

// DecRef decrements the reference count for the specified handle
// and deletes it it goes to zero.
//export DecRef
func DecRef(handle CGoHandle) {
	gopyh.DecRef(gopyh.CGoHandle(handle))
}

// IncRef increments the reference count for the specified handle.
//export IncRef
func IncRef(handle CGoHandle) {
	gopyh.IncRef(gopyh.CGoHandle(handle))
}

// NumHandles returns the number of handles currently in use.
//export NumHandles
func NumHandles() int {
	return gopyh.NumHandles()
}

// boolGoToPy converts a Go bool to python-compatible C.char
func boolGoToPy(b bool) C.char {
	if b {
		return 1
	}
	return 0
}

// boolPyToGo converts a python-compatible C.Char to Go bool
func boolPyToGo(b C.char) bool {
	if b != 0 {
		return true
	}
	return false
}

func complex64GoToPy(c complex64) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex64PyToGo(o *C.PyObject) complex64 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float32(v.real), float32(v.imag))
}

func complex128GoToPy(c complex128) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex128PyToGo(o *C.PyObject) complex128 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float64(v.real), float64(v.imag))
}

// --- generated code for package: pyexp below: ---

// ---- External Types Outside of Targeted Packages ---

// Converters for pointer handles for type: *time.Location
func ptrFromHandle_Ptr_time_Location(h CGoHandle) *time.Location {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*time.Location")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(time.Location{})).(*time.Location)
}
func handleFromPtr_Ptr_time_Location(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*time.Location", p))
}

// Converters for pointer handles for type: context.Context
func ptrFromHandle_context_Context(h CGoHandle) context.Context {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "context.Context")
	if p == nil {
		return nil
	}
	return p.(context.Context)
}
func handleFromPtr_context_Context(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("context.Context", p))
}

// Converters for pointer handles for type: logr.LogSink
func ptrFromHandle_logr_LogSink(h CGoHandle) logr.LogSink {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "logr.LogSink")
	if p == nil {
		return nil
	}
	return p.(logr.LogSink)
}
func handleFromPtr_logr_LogSink(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("logr.LogSink", p))
}

// Converters for non-pointer handles for type: logr.Logger
func ptrFromHandle_logr_Logger(h CGoHandle) *logr.Logger {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "logr.Logger")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(logr.Logger{})).(*logr.Logger)
}
func handleFromPtr_logr_Logger(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("logr.Logger", p))
}

// Converters for pointer handles for type: api.Engine
func ptrFromHandle_api_Engine(h CGoHandle) api.Engine {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "api.Engine")
	if p == nil {
		return nil
	}
	return p.(api.Engine)
}
func handleFromPtr_api_Engine(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("api.Engine", p))
}

// Converters for non-pointer handles for type: time.Location
func ptrFromHandle_time_Location(h CGoHandle) *time.Location {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "time.Location")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(time.Location{})).(*time.Location)
}
func handleFromPtr_time_Location(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("time.Location", p))
}

// Converters for non-pointer handles for type: time.Time
func ptrFromHandle_time_Time(h CGoHandle) *time.Time {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "time.Time")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(time.Time{})).(*time.Time)
}
func handleFromPtr_time_Time(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("time.Time", p))
}

// ---- Package: go ---

// ---- Types ---

// Converters for implicit pointer handles for type: []bool
func ptrFromHandle_Slice_bool(h CGoHandle) *[]bool {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]bool")
	if p == nil {
		return nil
	}
	return p.(*[]bool)
}
func deptrFromHandle_Slice_bool(h CGoHandle) []bool {
	p := ptrFromHandle_Slice_bool(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_bool(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]bool", p))
}

// --- wrapping slice: []bool ---
//export Slice_bool_CTor
func Slice_bool_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_bool(&[]bool{}))
}

//export Slice_bool_len
func Slice_bool_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_bool(handle))
}

//export Slice_bool_elem
func Slice_bool_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_bool(handle)
	return boolGoToPy(s[_idx])
}

//export Slice_bool_subslice
func Slice_bool_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_bool(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_bool(&ss))
}

//export Slice_bool_set
func Slice_bool_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_bool(handle)
	s[_idx] = boolPyToGo(_vl)
}

//export Slice_bool_append
func Slice_bool_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_bool(handle)
	*s = append(*s, boolPyToGo(_vl))
}

// Converters for implicit pointer handles for type: []byte
func ptrFromHandle_Slice_byte(h CGoHandle) *[]byte {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]byte")
	if p == nil {
		return nil
	}
	return p.(*[]byte)
}
func deptrFromHandle_Slice_byte(h CGoHandle) []byte {
	p := ptrFromHandle_Slice_byte(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_byte(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]byte", p))
}

// --- wrapping slice: []byte ---
//export Slice_byte_CTor
func Slice_byte_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_byte(&[]byte{}))
}

//export Slice_byte_len
func Slice_byte_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_byte(handle))
}

//export Slice_byte_elem
func Slice_byte_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_byte(handle)
	return C.char(s[_idx])
}

//export Slice_byte_subslice
func Slice_byte_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_byte(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_byte(&ss))
}

//export Slice_byte_set
func Slice_byte_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_byte(handle)
	s[_idx] = byte(_vl)
}

//export Slice_byte_append
func Slice_byte_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_byte(handle)
	*s = append(*s, byte(_vl))
}

// Converters for implicit pointer handles for type: []float32
func ptrFromHandle_Slice_float32(h CGoHandle) *[]float32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float32")
	if p == nil {
		return nil
	}
	return p.(*[]float32)
}
func deptrFromHandle_Slice_float32(h CGoHandle) []float32 {
	p := ptrFromHandle_Slice_float32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_float32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float32", p))
}

// --- wrapping slice: []float32 ---
//export Slice_float32_CTor
func Slice_float32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float32(&[]float32{}))
}

//export Slice_float32_len
func Slice_float32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_float32(handle))
}

//export Slice_float32_elem
func Slice_float32_elem(handle CGoHandle, _idx int) C.float {
	s := deptrFromHandle_Slice_float32(handle)
	return C.float(s[_idx])
}

//export Slice_float32_subslice
func Slice_float32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_float32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_float32(&ss))
}

//export Slice_float32_set
func Slice_float32_set(handle CGoHandle, _idx int, _vl C.float) {
	s := deptrFromHandle_Slice_float32(handle)
	s[_idx] = float32(_vl)
}

//export Slice_float32_append
func Slice_float32_append(handle CGoHandle, _vl C.float) {
	s := ptrFromHandle_Slice_float32(handle)
	*s = append(*s, float32(_vl))
}

// Converters for implicit pointer handles for type: []float64
func ptrFromHandle_Slice_float64(h CGoHandle) *[]float64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float64")
	if p == nil {
		return nil
	}
	return p.(*[]float64)
}
func deptrFromHandle_Slice_float64(h CGoHandle) []float64 {
	p := ptrFromHandle_Slice_float64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_float64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float64", p))
}

// --- wrapping slice: []float64 ---
//export Slice_float64_CTor
func Slice_float64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float64(&[]float64{}))
}

//export Slice_float64_len
func Slice_float64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_float64(handle))
}

//export Slice_float64_elem
func Slice_float64_elem(handle CGoHandle, _idx int) C.double {
	s := deptrFromHandle_Slice_float64(handle)
	return C.double(s[_idx])
}

//export Slice_float64_subslice
func Slice_float64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_float64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_float64(&ss))
}

//export Slice_float64_set
func Slice_float64_set(handle CGoHandle, _idx int, _vl C.double) {
	s := deptrFromHandle_Slice_float64(handle)
	s[_idx] = float64(_vl)
}

//export Slice_float64_append
func Slice_float64_append(handle CGoHandle, _vl C.double) {
	s := ptrFromHandle_Slice_float64(handle)
	*s = append(*s, float64(_vl))
}

// Converters for implicit pointer handles for type: []int
func ptrFromHandle_Slice_int(h CGoHandle) *[]int {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int")
	if p == nil {
		return nil
	}
	return p.(*[]int)
}
func deptrFromHandle_Slice_int(h CGoHandle) []int {
	p := ptrFromHandle_Slice_int(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int", p))
}

// --- wrapping slice: []int ---
//export Slice_int_CTor
func Slice_int_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int(&[]int{}))
}

//export Slice_int_len
func Slice_int_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int(handle))
}

//export Slice_int_elem
func Slice_int_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_int(handle)
	return C.longlong(s[_idx])
}

//export Slice_int_subslice
func Slice_int_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int(&ss))
}

//export Slice_int_set
func Slice_int_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_int(handle)
	s[_idx] = int(_vl)
}

//export Slice_int_append
func Slice_int_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int(handle)
	*s = append(*s, int(_vl))
}

// Converters for implicit pointer handles for type: []int16
func ptrFromHandle_Slice_int16(h CGoHandle) *[]int16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int16")
	if p == nil {
		return nil
	}
	return p.(*[]int16)
}
func deptrFromHandle_Slice_int16(h CGoHandle) []int16 {
	p := ptrFromHandle_Slice_int16(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int16", p))
}

// --- wrapping slice: []int16 ---
//export Slice_int16_CTor
func Slice_int16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int16(&[]int16{}))
}

//export Slice_int16_len
func Slice_int16_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int16(handle))
}

//export Slice_int16_elem
func Slice_int16_elem(handle CGoHandle, _idx int) C.short {
	s := deptrFromHandle_Slice_int16(handle)
	return C.short(s[_idx])
}

//export Slice_int16_subslice
func Slice_int16_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int16(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int16(&ss))
}

//export Slice_int16_set
func Slice_int16_set(handle CGoHandle, _idx int, _vl C.short) {
	s := deptrFromHandle_Slice_int16(handle)
	s[_idx] = int16(_vl)
}

//export Slice_int16_append
func Slice_int16_append(handle CGoHandle, _vl C.short) {
	s := ptrFromHandle_Slice_int16(handle)
	*s = append(*s, int16(_vl))
}

// Converters for implicit pointer handles for type: []int32
func ptrFromHandle_Slice_int32(h CGoHandle) *[]int32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int32")
	if p == nil {
		return nil
	}
	return p.(*[]int32)
}
func deptrFromHandle_Slice_int32(h CGoHandle) []int32 {
	p := ptrFromHandle_Slice_int32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int32", p))
}

// --- wrapping slice: []int32 ---
//export Slice_int32_CTor
func Slice_int32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int32(&[]int32{}))
}

//export Slice_int32_len
func Slice_int32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int32(handle))
}

//export Slice_int32_elem
func Slice_int32_elem(handle CGoHandle, _idx int) C.long {
	s := deptrFromHandle_Slice_int32(handle)
	return C.long(s[_idx])
}

//export Slice_int32_subslice
func Slice_int32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int32(&ss))
}

//export Slice_int32_set
func Slice_int32_set(handle CGoHandle, _idx int, _vl C.long) {
	s := deptrFromHandle_Slice_int32(handle)
	s[_idx] = int32(_vl)
}

//export Slice_int32_append
func Slice_int32_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_int32(handle)
	*s = append(*s, int32(_vl))
}

// Converters for implicit pointer handles for type: []int64
func ptrFromHandle_Slice_int64(h CGoHandle) *[]int64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int64")
	if p == nil {
		return nil
	}
	return p.(*[]int64)
}
func deptrFromHandle_Slice_int64(h CGoHandle) []int64 {
	p := ptrFromHandle_Slice_int64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int64", p))
}

// --- wrapping slice: []int64 ---
//export Slice_int64_CTor
func Slice_int64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int64(&[]int64{}))
}

//export Slice_int64_len
func Slice_int64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int64(handle))
}

//export Slice_int64_elem
func Slice_int64_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_int64(handle)
	return C.longlong(s[_idx])
}

//export Slice_int64_subslice
func Slice_int64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int64(&ss))
}

//export Slice_int64_set
func Slice_int64_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_int64(handle)
	s[_idx] = int64(_vl)
}

//export Slice_int64_append
func Slice_int64_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int64(handle)
	*s = append(*s, int64(_vl))
}

// Converters for implicit pointer handles for type: []int8
func ptrFromHandle_Slice_int8(h CGoHandle) *[]int8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int8")
	if p == nil {
		return nil
	}
	return p.(*[]int8)
}
func deptrFromHandle_Slice_int8(h CGoHandle) []int8 {
	p := ptrFromHandle_Slice_int8(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int8", p))
}

// --- wrapping slice: []int8 ---
//export Slice_int8_CTor
func Slice_int8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int8(&[]int8{}))
}

//export Slice_int8_len
func Slice_int8_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int8(handle))
}

//export Slice_int8_elem
func Slice_int8_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_int8(handle)
	return C.char(s[_idx])
}

//export Slice_int8_subslice
func Slice_int8_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int8(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int8(&ss))
}

//export Slice_int8_set
func Slice_int8_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_int8(handle)
	s[_idx] = int8(_vl)
}

//export Slice_int8_append
func Slice_int8_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_int8(handle)
	*s = append(*s, int8(_vl))
}

// Converters for implicit pointer handles for type: []rune
func ptrFromHandle_Slice_rune(h CGoHandle) *[]rune {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]rune")
	if p == nil {
		return nil
	}
	return p.(*[]rune)
}
func deptrFromHandle_Slice_rune(h CGoHandle) []rune {
	p := ptrFromHandle_Slice_rune(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_rune(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]rune", p))
}

// --- wrapping slice: []rune ---
//export Slice_rune_CTor
func Slice_rune_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_rune(&[]rune{}))
}

//export Slice_rune_len
func Slice_rune_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_rune(handle))
}

//export Slice_rune_elem
func Slice_rune_elem(handle CGoHandle, _idx int) C.long {
	s := deptrFromHandle_Slice_rune(handle)
	return C.long(s[_idx])
}

//export Slice_rune_subslice
func Slice_rune_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_rune(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_rune(&ss))
}

//export Slice_rune_set
func Slice_rune_set(handle CGoHandle, _idx int, _vl C.long) {
	s := deptrFromHandle_Slice_rune(handle)
	s[_idx] = rune(_vl)
}

//export Slice_rune_append
func Slice_rune_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_rune(handle)
	*s = append(*s, rune(_vl))
}

// Converters for implicit pointer handles for type: []string
func ptrFromHandle_Slice_string(h CGoHandle) *[]string {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]string")
	if p == nil {
		return nil
	}
	return p.(*[]string)
}
func deptrFromHandle_Slice_string(h CGoHandle) []string {
	p := ptrFromHandle_Slice_string(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_string(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]string", p))
}

// --- wrapping slice: []string ---
//export Slice_string_CTor
func Slice_string_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_string(&[]string{}))
}

//export Slice_string_len
func Slice_string_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_string(handle))
}

//export Slice_string_elem
func Slice_string_elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_Slice_string(handle)
	return C.CString(s[_idx])
}

//export Slice_string_subslice
func Slice_string_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_string(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_string(&ss))
}

//export Slice_string_set
func Slice_string_set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_Slice_string(handle)
	s[_idx] = C.GoString(_vl)
}

//export Slice_string_append
func Slice_string_append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_Slice_string(handle)
	*s = append(*s, C.GoString(_vl))
}

// Converters for implicit pointer handles for type: []uint
func ptrFromHandle_Slice_uint(h CGoHandle) *[]uint {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint")
	if p == nil {
		return nil
	}
	return p.(*[]uint)
}
func deptrFromHandle_Slice_uint(h CGoHandle) []uint {
	p := ptrFromHandle_Slice_uint(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint", p))
}

// --- wrapping slice: []uint ---
//export Slice_uint_CTor
func Slice_uint_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint(&[]uint{}))
}

//export Slice_uint_len
func Slice_uint_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint(handle))
}

//export Slice_uint_elem
func Slice_uint_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_uint(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint_subslice
func Slice_uint_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint(&ss))
}

//export Slice_uint_set
func Slice_uint_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_uint(handle)
	s[_idx] = uint(_vl)
}

//export Slice_uint_append
func Slice_uint_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint(handle)
	*s = append(*s, uint(_vl))
}

// Converters for implicit pointer handles for type: []uint16
func ptrFromHandle_Slice_uint16(h CGoHandle) *[]uint16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint16")
	if p == nil {
		return nil
	}
	return p.(*[]uint16)
}
func deptrFromHandle_Slice_uint16(h CGoHandle) []uint16 {
	p := ptrFromHandle_Slice_uint16(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint16", p))
}

// --- wrapping slice: []uint16 ---
//export Slice_uint16_CTor
func Slice_uint16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint16(&[]uint16{}))
}

//export Slice_uint16_len
func Slice_uint16_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint16(handle))
}

//export Slice_uint16_elem
func Slice_uint16_elem(handle CGoHandle, _idx int) C.ushort {
	s := deptrFromHandle_Slice_uint16(handle)
	return C.ushort(s[_idx])
}

//export Slice_uint16_subslice
func Slice_uint16_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint16(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint16(&ss))
}

//export Slice_uint16_set
func Slice_uint16_set(handle CGoHandle, _idx int, _vl C.ushort) {
	s := deptrFromHandle_Slice_uint16(handle)
	s[_idx] = uint16(_vl)
}

//export Slice_uint16_append
func Slice_uint16_append(handle CGoHandle, _vl C.ushort) {
	s := ptrFromHandle_Slice_uint16(handle)
	*s = append(*s, uint16(_vl))
}

// Converters for implicit pointer handles for type: []uint32
func ptrFromHandle_Slice_uint32(h CGoHandle) *[]uint32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint32")
	if p == nil {
		return nil
	}
	return p.(*[]uint32)
}
func deptrFromHandle_Slice_uint32(h CGoHandle) []uint32 {
	p := ptrFromHandle_Slice_uint32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint32", p))
}

// --- wrapping slice: []uint32 ---
//export Slice_uint32_CTor
func Slice_uint32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint32(&[]uint32{}))
}

//export Slice_uint32_len
func Slice_uint32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint32(handle))
}

//export Slice_uint32_elem
func Slice_uint32_elem(handle CGoHandle, _idx int) C.ulong {
	s := deptrFromHandle_Slice_uint32(handle)
	return C.ulong(s[_idx])
}

//export Slice_uint32_subslice
func Slice_uint32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint32(&ss))
}

//export Slice_uint32_set
func Slice_uint32_set(handle CGoHandle, _idx int, _vl C.ulong) {
	s := deptrFromHandle_Slice_uint32(handle)
	s[_idx] = uint32(_vl)
}

//export Slice_uint32_append
func Slice_uint32_append(handle CGoHandle, _vl C.ulong) {
	s := ptrFromHandle_Slice_uint32(handle)
	*s = append(*s, uint32(_vl))
}

// Converters for implicit pointer handles for type: []uint64
func ptrFromHandle_Slice_uint64(h CGoHandle) *[]uint64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint64")
	if p == nil {
		return nil
	}
	return p.(*[]uint64)
}
func deptrFromHandle_Slice_uint64(h CGoHandle) []uint64 {
	p := ptrFromHandle_Slice_uint64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint64", p))
}

// --- wrapping slice: []uint64 ---
//export Slice_uint64_CTor
func Slice_uint64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint64(&[]uint64{}))
}

//export Slice_uint64_len
func Slice_uint64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint64(handle))
}

//export Slice_uint64_elem
func Slice_uint64_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_uint64(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint64_subslice
func Slice_uint64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint64(&ss))
}

//export Slice_uint64_set
func Slice_uint64_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_uint64(handle)
	s[_idx] = uint64(_vl)
}

//export Slice_uint64_append
func Slice_uint64_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint64(handle)
	*s = append(*s, uint64(_vl))
}

// Converters for implicit pointer handles for type: []uint8
func ptrFromHandle_Slice_uint8(h CGoHandle) *[]uint8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint8")
	if p == nil {
		return nil
	}
	return p.(*[]uint8)
}
func deptrFromHandle_Slice_uint8(h CGoHandle) []uint8 {
	p := ptrFromHandle_Slice_uint8(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint8", p))
}

// --- wrapping slice: []uint8 ---
//export Slice_uint8_CTor
func Slice_uint8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint8(&[]uint8{}))
}

//export Slice_uint8_len
func Slice_uint8_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint8(handle))
}

//export Slice_uint8_elem
func Slice_uint8_elem(handle CGoHandle, _idx int) C.uchar {
	s := deptrFromHandle_Slice_uint8(handle)
	return C.uchar(s[_idx])
}

//export Slice_uint8_subslice
func Slice_uint8_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint8(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint8(&ss))
}

//export Slice_uint8_set
func Slice_uint8_set(handle CGoHandle, _idx int, _vl C.uchar) {
	s := deptrFromHandle_Slice_uint8(handle)
	s[_idx] = uint8(_vl)
}

//export Slice_uint8_append
func Slice_uint8_append(handle CGoHandle, _vl C.uchar) {
	s := ptrFromHandle_Slice_uint8(handle)
	*s = append(*s, uint8(_vl))
}

// ---- Package: pyexp ---

// ---- Types ---

// Converters for pointer handles for type: *pyexp.BasicOp
func ptrFromHandle_Ptr_pyexp_BasicOp(h CGoHandle) *pyexp.BasicOp {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*pyexp.BasicOp")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pyexp.BasicOp{})).(*pyexp.BasicOp)
}
func handleFromPtr_Ptr_pyexp_BasicOp(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*pyexp.BasicOp", p))
}

// Converters for pointer handles for type: *pyexp.ExecRequest
func ptrFromHandle_Ptr_pyexp_ExecRequest(h CGoHandle) *pyexp.ExecRequest {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*pyexp.ExecRequest")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pyexp.ExecRequest{})).(*pyexp.ExecRequest)
}
func handleFromPtr_Ptr_pyexp_ExecRequest(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*pyexp.ExecRequest", p))
}

// Converters for pointer handles for type: *pyexp.ExecResponse
func ptrFromHandle_Ptr_pyexp_ExecResponse(h CGoHandle) *pyexp.ExecResponse {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*pyexp.ExecResponse")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pyexp.ExecResponse{})).(*pyexp.ExecResponse)
}
func handleFromPtr_Ptr_pyexp_ExecResponse(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*pyexp.ExecResponse", p))
}

// Converters for pointer handles for type: *pyexp.Instruction
func ptrFromHandle_Ptr_pyexp_Instruction(h CGoHandle) *pyexp.Instruction {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*pyexp.Instruction")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pyexp.Instruction{})).(*pyexp.Instruction)
}
func handleFromPtr_Ptr_pyexp_Instruction(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*pyexp.Instruction", p))
}

// Converters for pointer handles for type: *pyexp.InstructionsBag
func ptrFromHandle_Ptr_pyexp_InstructionsBag(h CGoHandle) *pyexp.InstructionsBag {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*pyexp.InstructionsBag")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pyexp.InstructionsBag{})).(*pyexp.InstructionsBag)
}
func handleFromPtr_Ptr_pyexp_InstructionsBag(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*pyexp.InstructionsBag", p))
}

// Converters for pointer handles for type: *pyexp.PyVal
func ptrFromHandle_Ptr_pyexp_PyVal(h CGoHandle) *pyexp.PyVal {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*pyexp.PyVal")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pyexp.PyVal{})).(*pyexp.PyVal)
}
func handleFromPtr_Ptr_pyexp_PyVal(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*pyexp.PyVal", p))
}

// Converters for implicit pointer handles for type: []pyexp.Instruction
func ptrFromHandle_Slice_pyexp_Instruction(h CGoHandle) *[]pyexp.Instruction {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]pyexp.Instruction")
	if p == nil {
		return nil
	}
	return p.(*[]pyexp.Instruction)
}
func deptrFromHandle_Slice_pyexp_Instruction(h CGoHandle) []pyexp.Instruction {
	p := ptrFromHandle_Slice_pyexp_Instruction(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_pyexp_Instruction(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]pyexp.Instruction", p))
}

// --- wrapping slice: []pyexp.Instruction ---
//export Slice_pyexp_Instruction_CTor
func Slice_pyexp_Instruction_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_pyexp_Instruction(&[]pyexp.Instruction{}))
}

//export Slice_pyexp_Instruction_len
func Slice_pyexp_Instruction_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_pyexp_Instruction(handle))
}

//export Slice_pyexp_Instruction_elem
func Slice_pyexp_Instruction_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_pyexp_Instruction(handle)
	return handleFromPtr_pyexp_Instruction(&(s[_idx]))
}

//export Slice_pyexp_Instruction_subslice
func Slice_pyexp_Instruction_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_pyexp_Instruction(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_pyexp_Instruction(&ss))
}

//export Slice_pyexp_Instruction_set
func Slice_pyexp_Instruction_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_pyexp_Instruction(handle)
	s[_idx] = *ptrFromHandle_pyexp_Instruction(_vl)
}

//export Slice_pyexp_Instruction_append
func Slice_pyexp_Instruction_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_pyexp_Instruction(handle)
	*s = append(*s, *ptrFromHandle_pyexp_Instruction(_vl))
}

// Converters for pointer handles for type: any
func ptrFromHandle_any(h CGoHandle) any {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "any")
	if p == nil {
		return nil
	}
	return p.(any)
}
func handleFromPtr_any(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("any", p))
}

// Converters for non-pointer handles for type: pyexp.BasicOp
func ptrFromHandle_pyexp_BasicOp(h CGoHandle) *pyexp.BasicOp {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pyexp.BasicOp")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pyexp.BasicOp{})).(*pyexp.BasicOp)
}
func handleFromPtr_pyexp_BasicOp(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pyexp.BasicOp", p))
}

// Converters for non-pointer handles for type: pyexp.ExecRequest
func ptrFromHandle_pyexp_ExecRequest(h CGoHandle) *pyexp.ExecRequest {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pyexp.ExecRequest")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pyexp.ExecRequest{})).(*pyexp.ExecRequest)
}
func handleFromPtr_pyexp_ExecRequest(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pyexp.ExecRequest", p))
}

// Converters for non-pointer handles for type: pyexp.ExecResponse
func ptrFromHandle_pyexp_ExecResponse(h CGoHandle) *pyexp.ExecResponse {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pyexp.ExecResponse")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pyexp.ExecResponse{})).(*pyexp.ExecResponse)
}
func handleFromPtr_pyexp_ExecResponse(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pyexp.ExecResponse", p))
}

// Converters for non-pointer handles for type: pyexp.Instruction
func ptrFromHandle_pyexp_Instruction(h CGoHandle) *pyexp.Instruction {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pyexp.Instruction")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pyexp.Instruction{})).(*pyexp.Instruction)
}
func handleFromPtr_pyexp_Instruction(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pyexp.Instruction", p))
}

// Converters for non-pointer handles for type: pyexp.InstructionsBag
func ptrFromHandle_pyexp_InstructionsBag(h CGoHandle) *pyexp.InstructionsBag {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pyexp.InstructionsBag")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pyexp.InstructionsBag{})).(*pyexp.InstructionsBag)
}
func handleFromPtr_pyexp_InstructionsBag(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pyexp.InstructionsBag", p))
}

// Converters for non-pointer handles for type: pyexp.PyVal
func ptrFromHandle_pyexp_PyVal(h CGoHandle) *pyexp.PyVal {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pyexp.PyVal")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pyexp.PyVal{})).(*pyexp.PyVal)
}
func handleFromPtr_pyexp_PyVal(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pyexp.PyVal", p))
}

// Converters for pointer handles for type: pyexp.Runtime
func ptrFromHandle_pyexp_Runtime(h CGoHandle) pyexp.Runtime {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pyexp.Runtime")
	if p == nil {
		return nil
	}
	return p.(pyexp.Runtime)
}
func handleFromPtr_pyexp_Runtime(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pyexp.Runtime", p))
}

// Converters for implicit pointer handles for type: map[string][]string
func ptrFromHandle_Map_string_Slice_string(h CGoHandle) *map[string][]string {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string][]string")
	if p == nil {
		return nil
	}
	return p.(*map[string][]string)
}
func deptrFromHandle_Map_string_Slice_string(h CGoHandle) map[string][]string {
	p := ptrFromHandle_Map_string_Slice_string(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_Slice_string(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string][]string", p))
}

// --- wrapping map: map[string][]string ---
//export Map_string_Slice_string_CTor
func Map_string_Slice_string_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_Slice_string(&map[string][]string{}))
}

//export Map_string_Slice_string_len
func Map_string_Slice_string_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_Slice_string(handle))
}

//export Map_string_Slice_string_elem
func Map_string_Slice_string_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_Map_string_Slice_string(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_Slice_string(v)
}

//export Map_string_Slice_string_contains
func Map_string_Slice_string_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_Slice_string(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_Slice_string_set
func Map_string_Slice_string_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_Map_string_Slice_string(handle)
	s[C.GoString(_ky)] = deptrFromHandle_Slice_string(_vl)
}

//export Map_string_Slice_string_delete
func Map_string_Slice_string_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_Slice_string(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_Slice_string_keys
func Map_string_Slice_string_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_Slice_string(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

//export pyexp_Runtime_DiscoverDependencies
func pyexp_Runtime_DiscoverDependencies(_handle CGoHandle) CGoHandle {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "pyexp.Runtime")
	if __err != nil {
		return handleFromPtr_Slice_string(nil)
	}
	cret, __err := vifc.(pyexp.Runtime).DiscoverDependencies()

	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_string(nil)
	}
	return handleFromPtr_Slice_string(&cret)
}

//export pyexp_Runtime_Exec
func pyexp_Runtime_Exec(_handle CGoHandle, arg_0 CGoHandle) CGoHandle {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "pyexp.Runtime")
	if __err != nil {
		return handleFromPtr_Ptr_pyexp_ExecResponse(nil)
	}
	cret, __err := vifc.(pyexp.Runtime).Exec(*ptrFromHandle_pyexp_ExecRequest(arg_0))

	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_pyexp_ExecResponse(nil)
	}
	return handleFromPtr_Ptr_pyexp_ExecResponse(cret)
}

//export pyexp_Runtime_ExecWithEngine
func pyexp_Runtime_ExecWithEngine(_handle CGoHandle, ctx CGoHandle, req CGoHandle, e CGoHandle) CGoHandle {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "pyexp.Runtime")
	if __err != nil {
		return handleFromPtr_Ptr_pyexp_ExecResponse(nil)
	}
	cret, __err := vifc.(pyexp.Runtime).ExecWithEngine(ptrFromHandle_context_Context(ctx), *ptrFromHandle_pyexp_ExecRequest(req), ptrFromHandle_api_Engine(e))

	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_pyexp_ExecResponse(nil)
	}
	return handleFromPtr_Ptr_pyexp_ExecResponse(cret)
}

// ---- Structs ---

// --- wrapping struct: pyexp.InstructionsBag ---
//export pyexp_InstructionsBag_CTor
func pyexp_InstructionsBag_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_pyexp_InstructionsBag(&pyexp.InstructionsBag{}))
}

//export pyexp_InstructionsBag_Instructions_Get
func pyexp_InstructionsBag_Instructions_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_pyexp_InstructionsBag(handle)
	return handleFromPtr_Slice_pyexp_Instruction(&op.Instructions)
}

//export pyexp_InstructionsBag_Instructions_Set
func pyexp_InstructionsBag_Instructions_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_pyexp_InstructionsBag(handle)
	op.Instructions = deptrFromHandle_Slice_pyexp_Instruction(val)
}

// --- wrapping struct: pyexp.PyVal ---
//export pyexp_PyVal_CTor
func pyexp_PyVal_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_pyexp_PyVal(&pyexp.PyVal{}))
}

//export pyexp_PyVal_Value_Get
func pyexp_PyVal_Value_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_pyexp_PyVal(handle)
	return C.CString(op.Value)
}

//export pyexp_PyVal_Value_Set
func pyexp_PyVal_Value_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_pyexp_PyVal(handle)
	op.Value = C.GoString(val)
}

//export pyexp_PyVal_Timestamp_Get
func pyexp_PyVal_Timestamp_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_pyexp_PyVal(handle)
	return handleFromPtr_time_Time(&op.Timestamp)
}

//export pyexp_PyVal_Timestamp_Set
func pyexp_PyVal_Timestamp_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_pyexp_PyVal(handle)
	op.Timestamp = *ptrFromHandle_time_Time(val)
}

//export pyexp_PyVal_Fresh_Get
func pyexp_PyVal_Fresh_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_pyexp_PyVal(handle)
	return boolGoToPy(op.Fresh)
}

//export pyexp_PyVal_Fresh_Set
func pyexp_PyVal_Fresh_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_pyexp_PyVal(handle)
	op.Fresh = boolPyToGo(val)
}

// --- wrapping struct: pyexp.BasicOp ---
//export pyexp_BasicOp_CTor
func pyexp_BasicOp_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_pyexp_BasicOp(&pyexp.BasicOp{}))
}

// --- wrapping struct: pyexp.ExecRequest ---
//export pyexp_ExecRequest_CTor
func pyexp_ExecRequest_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_pyexp_ExecRequest(&pyexp.ExecRequest{}))
}

//export pyexp_ExecRequest_Headers_Get
func pyexp_ExecRequest_Headers_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_pyexp_ExecRequest(handle)
	return handleFromPtr_Map_string_Slice_string(&op.Headers)
}

//export pyexp_ExecRequest_Headers_Set
func pyexp_ExecRequest_Headers_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_pyexp_ExecRequest(handle)
	op.Headers = deptrFromHandle_Map_string_Slice_string(val)
}

//export pyexp_ExecRequest_Payload_Get
func pyexp_ExecRequest_Payload_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_pyexp_ExecRequest(handle)
	return handleFromPtr_any(op.Payload)
}

//export pyexp_ExecRequest_Payload_Set
func pyexp_ExecRequest_Payload_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_pyexp_ExecRequest(handle)
	op.Payload = ptrFromHandle_any(val)
}

//export pyexp_ExecRequest_EntityID_Get
func pyexp_ExecRequest_EntityID_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_pyexp_ExecRequest(handle)
	return C.CString(op.EntityID)
}

//export pyexp_ExecRequest_EntityID_Set
func pyexp_ExecRequest_EntityID_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_pyexp_ExecRequest(handle)
	op.EntityID = C.GoString(val)
}

//export pyexp_ExecRequest_Timestamp_Get
func pyexp_ExecRequest_Timestamp_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_pyexp_ExecRequest(handle)
	return handleFromPtr_time_Time(&op.Timestamp)
}

//export pyexp_ExecRequest_Timestamp_Set
func pyexp_ExecRequest_Timestamp_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_pyexp_ExecRequest(handle)
	op.Timestamp = *ptrFromHandle_time_Time(val)
}

//export pyexp_ExecRequest_Logger_Get
func pyexp_ExecRequest_Logger_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_pyexp_ExecRequest(handle)
	return handleFromPtr_logr_Logger(&op.Logger)
}

//export pyexp_ExecRequest_Logger_Set
func pyexp_ExecRequest_Logger_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_pyexp_ExecRequest(handle)
	op.Logger = *ptrFromHandle_logr_Logger(val)
}

// --- wrapping struct: pyexp.ExecResponse ---
//export pyexp_ExecResponse_CTor
func pyexp_ExecResponse_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_pyexp_ExecResponse(&pyexp.ExecResponse{}))
}

//export pyexp_ExecResponse_Value_Get
func pyexp_ExecResponse_Value_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_pyexp_ExecResponse(handle)
	return handleFromPtr_any(op.Value)
}

//export pyexp_ExecResponse_Value_Set
func pyexp_ExecResponse_Value_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_pyexp_ExecResponse(handle)
	op.Value = ptrFromHandle_any(val)
}

//export pyexp_ExecResponse_Timestamp_Get
func pyexp_ExecResponse_Timestamp_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_pyexp_ExecResponse(handle)
	return handleFromPtr_time_Time(&op.Timestamp)
}

//export pyexp_ExecResponse_Timestamp_Set
func pyexp_ExecResponse_Timestamp_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_pyexp_ExecResponse(handle)
	op.Timestamp = *ptrFromHandle_time_Time(val)
}

//export pyexp_ExecResponse_EntityID_Get
func pyexp_ExecResponse_EntityID_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_pyexp_ExecResponse(handle)
	return C.CString(op.EntityID)
}

//export pyexp_ExecResponse_EntityID_Set
func pyexp_ExecResponse_EntityID_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_pyexp_ExecResponse(handle)
	op.EntityID = C.GoString(val)
}

//export pyexp_ExecResponse_Instructions_Get
func pyexp_ExecResponse_Instructions_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_pyexp_ExecResponse(handle)
	return handleFromPtr_Slice_pyexp_Instruction(&op.Instructions)
}

//export pyexp_ExecResponse_Instructions_Set
func pyexp_ExecResponse_Instructions_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_pyexp_ExecResponse(handle)
	op.Instructions = deptrFromHandle_Slice_pyexp_Instruction(val)
}

// --- wrapping struct: pyexp.Instruction ---
//export pyexp_Instruction_CTor
func pyexp_Instruction_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_pyexp_Instruction(&pyexp.Instruction{}))
}

//export pyexp_Instruction_Operation_Get
func pyexp_Instruction_Operation_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_pyexp_Instruction(handle)
	return C.longlong(int(op.Operation))
}

//export pyexp_Instruction_Operation_Set
func pyexp_Instruction_Operation_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_pyexp_Instruction(handle)
	op.Operation = pyexp.InstructionOp(int(val))
}

//export pyexp_Instruction_FQN_Get
func pyexp_Instruction_FQN_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_pyexp_Instruction(handle)
	return C.CString(op.FQN)
}

//export pyexp_Instruction_FQN_Set
func pyexp_Instruction_FQN_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_pyexp_Instruction(handle)
	op.FQN = C.GoString(val)
}

//export pyexp_Instruction_EntityID_Get
func pyexp_Instruction_EntityID_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_pyexp_Instruction(handle)
	return C.CString(op.EntityID)
}

//export pyexp_Instruction_EntityID_Set
func pyexp_Instruction_EntityID_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_pyexp_Instruction(handle)
	op.EntityID = C.GoString(val)
}

//export pyexp_Instruction_Timestamp_Get
func pyexp_Instruction_Timestamp_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_pyexp_Instruction(handle)
	return handleFromPtr_time_Time(&op.Timestamp)
}

//export pyexp_Instruction_Timestamp_Set
func pyexp_Instruction_Timestamp_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_pyexp_Instruction(handle)
	op.Timestamp = *ptrFromHandle_time_Time(val)
}

//export pyexp_Instruction_Value_Get
func pyexp_Instruction_Value_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_pyexp_Instruction(handle)
	return handleFromPtr_any(op.Value)
}

//export pyexp_Instruction_Value_Set
func pyexp_Instruction_Value_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_pyexp_Instruction(handle)
	op.Value = ptrFromHandle_any(val)
}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

//export pyexp_PyExecReq
func pyexp_PyExecReq(jsonPayload *C.char, p *C.PyObject) CGoHandle {
	_fun_arg := p
	cret, __err := pyexp.PyExecReq(C.GoString(jsonPayload), func(FQN string, entityID string, timestamp string, val *pyexp.PyVal) string {
		if C.PyCallable_Check(_fun_arg) == 0 {
			return C.GoString(nil)
		}
		_gstate := C.PyGILState_Ensure()
		_fcargs := C.PyTuple_New(4)
		C.PyTuple_SetItem(_fcargs, 0, C.gopy_build_string(C.CString(FQN)))
		C.PyTuple_SetItem(_fcargs, 1, C.gopy_build_string(C.CString(entityID)))
		C.PyTuple_SetItem(_fcargs, 2, C.gopy_build_string(C.CString(timestamp)))
		C.PyTuple_SetItem(_fcargs, 3, C.gopy_build_int64(C.int64_t(handleFromPtr_Ptr_pyexp_PyVal(val))))
		_fcret := C.PyObject_CallObject(_fun_arg, _fcargs)
		C.gopy_decref(_fcargs)
		C.gopy_err_handle()
		C.PyGILState_Release(_gstate)
		return C.GoString(C.PyBytes_AsString(_fcret))
	})

	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_pyexp_ExecRequest(nil)
	}
	return handleFromPtr_pyexp_ExecRequest(&cret)
}

// ---- Functions ---

//export pyexp_MarshalExecResponse
func pyexp_MarshalExecResponse(resp CGoHandle) *C.char {
	return C.CString(pyexp.MarshalExecResponse(*ptrFromHandle_pyexp_ExecResponse(resp)))

}

//export pyexp_New
func pyexp_New(program *C.char, fqn *C.char) CGoHandle {
	cret, __err := pyexp.New(C.GoString(program), C.GoString(fqn))

	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_pyexp_Runtime(nil)
	}
	return handleFromPtr_pyexp_Runtime(cret)
}

//export pyexp_PyTime
func pyexp_PyTime(str *C.char, layout *C.char) CGoHandle {
	cret, __err := pyexp.PyTime(C.GoString(str), C.GoString(layout))

	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_time_Time(nil)
	}
	return handleFromPtr_time_Time(&cret)
}
